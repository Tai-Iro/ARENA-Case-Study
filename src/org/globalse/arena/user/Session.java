/*
 * Copyright 2004 (C) Applied Software Engineering--TU Muenchen
 *                    http://wwwbruegge.in.tum.de
 *
 * This file is part of ARENA.
 *
 * ARENA is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * ARENA is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ARENA; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package org.globalse.arena.user;

import java.util.Date;
import java.util.logging.Logger;
import org.globalse.arena.remote.exceptions.InvalidTicketException;


/**
 * A Session represents an authenticated user. It includes the id of the authenticated
 * user, the date it was created, and an encrypted signature that makes it more difficult
 * to forge sessions. The signature is computed and set by a separate class,
 * TokenSigner. Sessions are transmitted over the wire in string form, called tickets.
 * The getTicket() and the Session(String) constructor are used to convert back and
 * forth between Session and tickets.
 *
 * @author Michael Nagel
 */
public class Session implements Token {
	
	private static Logger logger = Logger.getLogger("org.globalse.arena.user");
	private long userId;
	private Date date;
	private String signature;
	
	/**
	 * Creates a new session object for a user specified by its id.
	 */
	public Session(long userId) {
		this.userId = userId;
		this.date = new Date();
	}
	
	/**
	 * Creates a new session object from its string representation. If the
	 * specified code is invalid (e.g., wrong form, missing signature, etc.),
	 * through an InvalidSessionException.
	 */
	public Session(String ticket) throws InvalidTicketException {
		if (ticket == null) {
			throw new InvalidTicketException("Ticket \"" + ticket + "\" is invalid.");
		}
		int marker = ticket.indexOf('Z');
		if (marker < idLength() + uidLength() + dateLength()) {
			throw new InvalidTicketException("Ticket \"" + ticket + "\" is invalid.");
		}
		if (!getId().equals(ticket.substring(0, idLength()))) {
			throw new InvalidTicketException("Ticket \"" + ticket + "\" is invalid.");
		}
		userId = parseUid(ticket.substring(idLength(), idLength() + uidLength()));
		date = parseDate(ticket.substring(idLength() + uidLength(), idLength() + uidLength() + dateLength()));
		signature = ticket.substring(marker + 1);
	}

	/**
	 * Synonym for getTicket()
	 */
	final public String toString() {
		return getTicket();
	}

	/**
	 * Returns a string representation of the session, by concatenating the
	 * session id, the user id, the date (as a long), a marker, and the signature.
	 * The signature is set by the gatekeeper before invoking this method.
	 */
	final public String getTicket() {
		if (signature == null)
			return null;
		return getCode() + "Z" + getSignature();
	}
	
	final public String getId() {
		return "USR";
	}
	
	private int idLength() {
		return getId().length();
	}

	/**
	 * Returns the user id associated with this session.
	 */
	final public long getUserId() {
		return userId;
	}

	/**
	 * Returns the date this session was created.
	 */
	final public Date getDate() {
		return date;
	}
	
	/**
	 * Returns the encoded part of this session (ticket minus signature and marker).
	 */
	final public String getCode() {
		return getId() + encodeLong(userId) + encodeLong(date.getTime());
	}

	/**
	 * Returns the signature of this session.
	 */
	final public String getSignature() {
		return signature;
	}

	/**
	 * Sets the signature associated with this session, usually generated by
	 * TokenSigner.
	 */
	final public void setSignature(String signature) {
		this.signature = signature;
	}
	
	final private static int longLength() {
		return 16;
	}
	
	private static long parseLong(String str)
		throws InvalidTicketException {
		long res = 0;
		try {
			res = Long.parseLong(str, 16);
		} catch (NumberFormatException e) {
			logger.warning("decodeLong throwing invalid format exception.");
			throw new InvalidTicketException("Ticket \"" + str + "\" is invalid.");
		}
		return res;
	}
	
	private static String encodeLong(long val) {
		String comp = "";
		comp = Long.toHexString(val);
		while (comp.length() < 16)
			comp = "0" + comp;
		return comp;
	}
	
	private static int uidLength() {
		return longLength();
	}
	
	private static long parseUid(String str) throws InvalidTicketException {
		return parseLong(str);
	}
	
	private static int dateLength() {
		return longLength();
	}
	
	private static Date parseDate(String str)
		throws InvalidTicketException {
		return new Date(parseLong(str));
	}
	
}
